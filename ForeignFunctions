Tragically, not every program in the world is written in Rust. 
There are many critical libraries and interfaces implemented in other languages that 
we would like to be able to use in our Rust programs.

Rust’s foreign function interface (FFI) lets Rust code call functions written in C, 
and in some cases C++. 
Since most operating systems offer C interfaces, Rust’s foreign function interface allows 
immediate access to all sorts of low-level facilities.

Given its primary use as a systems programming language, C has always been surprisingly 
loose about its types’ representations: an int is typically 32 bits long, but could be longer, 
or as short as 16 bits; a C char may be signed or unsigned; and so on. 
To cope with this variability, Rust’s std::os::raw module defines a set of Rust types 
that are guaranteed to have the same representation as certain C types.

C type	        Corresponding std::os::raw type
short	                   c_short
int	                       c_int
long	                   c_long
long long	               c_longlong
unsigned short	           c_ushort
unsigned, unsigned int	   c_uint
unsigned long	           c_ulong
unsigned long long	       c_ulonglong
char	                   c_char
signed char	               c_schar
unsigned char	           c_uchar
float	                   c_float
double	                   c_double
void *, const void *	   *mut c_void, *const c_void

For defining Rust struct types compatible with C structs, you can use the #[repr(C)] attribute.
Placing #[repr(C)] above a struct definition asks Rust to lay out the struct’s fields in memory 
the same way a C compiler would lay out the analogous C struct type.

For example, libgit2’s git2/errors.h header file defines the following C struct to provide details about a previously reported error:

typedef struct {
    char *message;
    int klass;
} git_error;

You can define a Rust type with an identical representation as follows:

use std::os::raw::{c_char, c_int};

#[repr(C)]
pub struct git_error {
    pub message: *const c_char,
    pub klass: c_int
}

The #[repr(C)] attribute affects only the layout of the struct itself, 
not the representations of its individual fields, so to match the C struct, 
each field must use the C-like type as well: *const c_char for char *, c_int for int, and so on.

In this particular case, the #[repr(C)] attribute probably doesn’t change the layout of git_error. 
There really aren’t too many interesting ways to lay out a pointer and an integer.
But whereas C and C++ guarantee that a structure’s members appear in memory in the order they’re 
declared, each at a distinct address, Rust reorders fields to minimize the overall size of the 
struct, and zero-sized types take up no space.

You can also use #[repr(C)] to control the representation of C-style enums:

#[repr(C)]
#[allow(non_camel_case_types)]
enum git_error_code {
    GIT_OK         =  0,
    GIT_ERROR      = -1,
    GIT_ENOTFOUND  = -3,
    GIT_EEXISTS    = -4,
    ...
}

You can also ask Rust to give an enum the same representation as some integer type. 
Starting the preceding definition with #[repr(i16)] would give you a 16-bit type with the 
same representation as the following C++ enum:

#include <stdint.h>

enum git_error_code: int16_t {
    GIT_OK         =  0,
    GIT_ERROR      = -1,
    GIT_ENOTFOUND  = -3,
    GIT_EEXISTS    = -4,
    ...
};

Suppose you have a C struct that uses a union to hold some data and a tag value to indicate which field of the union should be used, similar to a Rust enum.

enum tag {
    FLOAT = 0,
    INT   = 1,
};

union number {
    float f;
    short i;
};

struct tagged_number {
    tag t;
    number n;
};

Rust code can interoperate with this structure by applying #[repr(C)] to the enum, 
structure, and union types, and using a match statement that selects a union field 
within a larger struct based on the tag:

#[repr(C)]
enum Tag {
    Float = 0,
    Int = 1
}

#[repr(C)]
union FloatOrInt {
    f: f32,
    i: i32,
}

#[repr(C)]
struct Value {
    tag: Tag,
    union: FloatOrInt
}

fn is_zero(v: Value) -> bool {
    use self::Tag::*;
    unsafe {
        match v {
            Value { tag: Int, union: FloatOrInt { i: 0 } } => true,
            Value { tag: Float, union: FloatOrInt { f: num } } => (num == 0.0),
            _ => false
        }
    }
}

Passing strings between Rust and C is a little harder. 
C represents a string as a pointer to an array of characters, terminated by a null character.
Rust, on the other hand, stores the length of a string explicitly, either as a field of a String 
or as the second word of a fat reference &str.

Rust strings are not null-terminated; in fact, 
they may include null characters in their contents, like any other character.

This means that you can’t borrow a Rust string as a C string: if you pass C code a pointer into a Rust string, 
it could mistake an embedded null character for the end of the string or run off the end looking for a 
terminating null that isn’t there.

This situation effectively forces Rust to treat C strings as types entirely distinct from String and &str. 
In the std::ffi module, the CString and CStr types represent owned and borrowed null-terminated arrays of bytes. 
Compared to String and str, the methods on CString and CStr are quite limited, restricted to construction and conversion to other types.

Declaring Foreign Functions and Variables:-
-------------------------------------------
An extern block declares functions or variables defined in some other library 
that the final Rust executable will be linked with.

For example, on most platforms, every Rust program is linked against the standard C library, 
so we can tell Rust about the C library’s strlen function like this:

use std::os::raw::c_char;

extern {
    fn strlen(s: *const c_char) -> usize;
}