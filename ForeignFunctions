Tragically, not every program in the world is written in Rust. 
There are many critical libraries and interfaces implemented in other languages that 
we would like to be able to use in our Rust programs.

Rust’s foreign function interface (FFI) lets Rust code call functions written in C, 
and in some cases C++. 
Since most operating systems offer C interfaces, Rust’s foreign function interface allows 
immediate access to all sorts of low-level facilities.

Given its primary use as a systems programming language, C has always been surprisingly 
loose about its types’ representations: an int is typically 32 bits long, but could be longer, 
or as short as 16 bits; a C char may be signed or unsigned; and so on. 
To cope with this variability, Rust’s std::os::raw module defines a set of Rust types 
that are guaranteed to have the same representation as certain C types.

C type	        Corresponding std::os::raw type
short	                   c_short
int	                       c_int
long	                   c_long
long long	               c_longlong
unsigned short	           c_ushort
unsigned, unsigned int	   c_uint
unsigned long	           c_ulong
unsigned long long	       c_ulonglong
char	                   c_char
signed char	               c_schar
unsigned char	           c_uchar
float	                   c_float
double	                   c_double
void *, const void *	   *mut c_void, *const c_void