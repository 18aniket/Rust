Rust has three kinds of struct types, named-field, tuple-like, and unit-like.

A named-field struct gives a name to each component.
A tuple-like struct identifies them by the order in which they appear.
Unit-like structs have no components at all.

Named-Field struct:-
--------------------
struct GreyScaleMap {
       pixels: Vec<u8>,
       size: (usize,usize)
}

You can construct a value of this type with a struct expression, like this :-
let width = 1024;
let height = 576;
let image = GrayscaleMap {
    pixels: vec![0; width * height],
    size: (width, height)
};

fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {
    assert_eq!(pixels.len(), size.0 * size.1);
    GrayscaleMap { pixels, size }
}

To access a struct’s fields, use the familiar . operator:

assert_eq!(image.size, (1024, 576));
assert_eq!(image.pixels.len(), 1024 * 576);

Even if a struct is declared pub, its fields can be private:

/// A rectangle of eight-bit grayscale pixels.
pub struct GrayscaleMap {
    pixels: Vec<u8>,
    size: (usize, usize)
}

/// Two possible alternatives for what a `Broom` could be working on.
#[derive(Copy, Clone)]
enum BroomIntent { FetchWater, DumpWater }

// In this game, brooms are monsters. You'll see.
struct Broom {
    name: String,
    height: u32,
    health: u32,
    position: (f32, f32, f32),
    intent: BroomIntent
}

fn chop(b: Broom) -> (Broom, Broom) {

    // Initialize `broom1` mostly from `b`, changing only `height`. Since
    // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.
    let mut broom1 = Broom { height: b.height / 2, .. b }

    // Initialize `broom2` mostly from `broom1`. Since `String` is not
    // `Copy`, we must clone `name` explicitly.
    let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };

    // Give each fragment a distinct name.
    broom1.name.push_str(" I");
    broom2.name.push_str(" II");

    (broom1, broom2)
}

let hokey = Broom {
    name: "Hokey".to_string(),
    height: 60,
    health: 100,
    position: (100.0, 200.0, 0.0),
    intent: BroomIntent::FetchWater
};

let (hokey1, hokey2) = chop(hokey);

Tuple-Like structs:-
--------------------
The second kind of struct type is called a tuple-like struct, because it resembles a tuple:

struct Bounds(usize, usize);

You construct a value of this type much as you would construct a tuple, except that you must include the struct name:

let image_bounds = Bounds(1024, 768);

The values held by a tuple-like struct are called elements, just as the values of a tuple are. You access them just as you would a tuple’s:

assert_eq!(image_bounds.0 * image_bounds.1, 786432);
Individual elements of a tuple-like struct may be public or not:

pub struct Bounds(pub usize, pub usize);

Tuple-like structs are good for newtypes, structs with a single component that you define to get stricter type checking. 
For example, if you are working with ASCII-only text, you might define a newtype like this.

struct Ascii(Vec<u8>);

Using this type for your ASCII strings is much better than simply passing around Vec<u8> buffers and explaining what they are in the comments.
The newtype helps Rust catch mistakes where some other byte buffer is passed to a function expecting ASCII text.

Unit-like structs:-
-------------------
The third kind of struct is a little obscure: it declares a struct type with no elements at all:

struct Onesuch;

A value of such a type occupies no memory, much like the unit type (). 
Rust doesn’t bother actually storing unit-like struct values in memory or generating code to operate on them, 
because it can tell everything it might need to know about the value from its type alone. 
But logically, an empty struct is a type with values like any other—or more precisely, a type of which there is only a single value:

let o = Onesuch;

You’ve already encountered a unit-like struct when reading about the .. range operator in “Fields and Elements”.
Whereas an expression like 3..5 is shorthand for the struct value Range { start: 3, end: 5 }, 
the expression .., a range omitting both endpoints, is shorthand for the unit-like struct value RangeFull.





