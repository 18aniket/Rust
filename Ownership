You  can  move  values  from  one  owner  to  another. This allows you to  build,  rearrange, and tear down the tree.

Very simple types like integers, floating-point numbers, and characters are excused from the ownership rules. These are called Copy types.

The standard library provides the reference-counted pointer types Rc and Arc, which allow values to have multiple owners, under some restrictions.

You can “borrow a reference” to a value; references are non-owning pointers, with limited lifetimes.

Example:-
Python Code:-
s = ['udon', 'ramen', 'soba']
t = s
u = s

Rust Code:-
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s;
let u = s;

Like C and C++, Rust puts plain string literals like "udon" in read-only memory, 
so for a clearer comparison with the C++ and Python examples, we call to_string here to get heap-allocated String values.

what happens when we reach the initialization let u = s;? This would assign the uninitialized value s to u. Rust prudently prohibits using uninitialized values.
Still wants to do:-
The price you pay is that you must explicitly ask for copies when you want them. 
If you want to end up in the same state as the C++ program, with each variable holding an independent copy of the structure, you must call the vector’s clone method, which performs a deep copy of the vector and its elements:

let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s.clone();
let u = s.clone();

More Operations That Move
=========================

let mut s = "Govinda".to_string();
s = "Siddhartha".to_string(); // value "Govinda" dropped here

let mut s = "Govinda".to_string();
let t = s;
s = "Siddhartha".to_string(); // nothing is dropped here

Summary:-
---------
We’ve used initializations and assignments in the examples here because they’re simple, 
but Rust applies move semantics to almost any use of a value. 
Passing arguments to functions moves ownership to the function’s parameters; 
returning a value from a function moves ownership to the caller. Building a tuple moves the values into the tuple. And so on.

More than the Summary:-
-------------------------
Moving values around like this may sound inefficient, but there are two things to keep in mind. First, the moves always apply to the value proper, not the heap storage they own. For vectors and strings, 
the value proper is the three-word header alone; the potentially large element arrays and text buffers sit where they are in the heap. 
Second, the Rust compiler’s code generation is good at “seeing through” all these moves; in practice, the machine code often stores the value directly where it belongs.


Moves and Control Flow:-(To be must known)
==========================================

let x = vec![10, 20, 30];
if c {
    f(x); // ... ok to move from x here
} else {
    g(x); // ... and ok to also move from x here
}
h(x); // bad: x is uninitialized here if either path uses it.


let x = vec![10, 20, 30];
while f() {
    g(x); // bad: x would be moved in first iteration,
          // uninitialized in second
}


let mut x = vec![10, 20, 30];
while f() {
    g(x);           // move from x
    x = h();        // give x a fresh value
}
e(x);


Moves and Indexed Content:-
===========================
// Build a vector of the strings "101", "102", ... "105"
let mut v = Vec::new();
for i in 101 .. 106 {
    v.push(i.to_string());
}

// Pull out random elements from the vector.
let third = v[2]; // error: Cannot move out of index of Vec
let fifth = v[4]; // here too

For this to work, Rust would somehow need to remember that the third and fifth elements of the vector have become uninitialized, 
and track that information until the vector is dropped. In the most general case, 
vectors would need to carry around extra information with them to indicate which elements are live and which have become uninitialized. 
That is clearly not the right behavior for a systems programming language.







